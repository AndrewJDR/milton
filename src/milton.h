#pragma once

// Rename types for convenience
typedef int8_t      int8;
typedef uint8_t     uint8;
typedef int16_t     int16;
typedef uint16_t    uint16;
typedef int32_t     int32;
typedef uint32_t    uint32;
typedef int64_t     int64;
typedef uint64_t    uint64;
typedef int32_t     bool32;

#if defined(_MSC_VER)
#define true 1
#define false 0
#endif

#define stack_count(arr) (sizeof((arr)) / sizeof((arr)[0]))

inline int64 absl(int64 a)
{
    return a < 0 ? -a : a;
}

inline int64 maxl(int64 a, int64 b)
{
    return a > b? a : b;
}

inline int64 minl(int64 a, int64 b)
{
    return a < b? a : b;
}


#include <math.h>  // powf

#include "vector.generated.h"  // Generated by metaprogram

typedef struct Rect_s
{
    union
    {
        struct
        {
            v2l top_left;
            v2l bot_right;
        };
        struct
        {
            int64 left;
            int64 top;
            int64 right;
            int64 bottom;
        };
    };
}Rect;

typedef struct Brush_s
{
    int64 view_scale;
    int64 radius;  // This should be replaced by a BrushType and some union containing brush info.
} Brush;

typedef struct Stroke_s
{
    v2l*        points;
    v2l*        rpoints;
    int64       num_points;
    Brush       brush;

} Stroke;

typedef struct MiltonState_s
{
    int32_t     full_width;             // Dimensions of the raster
    int32_t     full_height;
    uint8_t     bytes_per_pixel;
    uint8_t*    raster_buffer;
    size_t      raster_buffer_size;

    v2l screen_size;

    // Maps screen_size to a rectangle in our infinite canvas.
    int64 view_scale;

    // Current stroke.
    v2l         stroke_points[4096];
    int64       num_stroke_points;

    // Before we get our nice spacial partition...
    Stroke    stored_strokes[4096];
    int64     num_stored_strokes;

    // Heap
    Arena*      root_arena;         // Persistent memory.
    Arena*      transient_arena;    // Gets reset after every call to milton_update().

} MiltonState;

typedef struct MiltonInput_s
{
    bool32 full_refresh;
    bool32 reset;
    v2l* brush;
    int scale;
} MiltonInput;

static void milton_init(MiltonState* milton_state)
{
    // Allocate enough memory for the maximum possible supported resolution. As
    // of now, it seems like future 8k displays will adopt this resolution.
    milton_state->full_width      = 7680;
    milton_state->full_height     = 4320;
    milton_state->bytes_per_pixel = 4;
    milton_state->view_scale      = ((int64)1 << 16);
    // A view_scale of a billion puts the initial scale at one meter.

    int closest_power_of_two = (1 << 27);  // Ceiling of log2(width * height * bpp)
    milton_state->raster_buffer_size = closest_power_of_two;

    milton_state->raster_buffer = arena_alloc_array(milton_state->root_arena,
            milton_state->raster_buffer_size, uint8_t);
}

static Rect bounding_rect_for_stroke(v2l points[], int64 num_points)
{
    assert (num_points > 0);

    v2l top_left = points[0];
    v2l bot_right = points[0];

    for (int64 i = 1; i < num_points; ++i)
    {
        v2l point = points[i];
        if (point.x < top_left.x) top_left.x = point.x;
        if (point.y > top_left.y) top_left.x = point.x;
        if (point.x > bot_right.x) bot_right.x = point.x;
        if (point.y > bot_right.y) bot_right.y = point.y;
    }
    Rect rect = { top_left, bot_right };
    return rect;
}

    // Move from infinite canvas to raster
inline static v2l canvas_to_raster(MiltonState* milton_state, v2l canvas_point)
{
    v2l screen_center = invscale_v2l(milton_state->screen_size, 2);
    v2l point = canvas_point;
    point = invscale_v2l(point, milton_state->view_scale);
    point = add_v2l     ( point, screen_center );
    return point;
}

    // Move to infinite canvas
inline static v2l raster_to_canvas(MiltonState* milton_state, v2l raster_point)
{
    v2l screen_center = invscale_v2l(milton_state->screen_size, 2);
    v2l canvas_point = raster_point;
    canvas_point = sub_v2l   ( canvas_point ,  screen_center );
    canvas_point = scale_v2l (canvas_point, milton_state->view_scale);
    return canvas_point;
}

typedef struct BitScanResult_s
{
    uint32 index;
    bool32 found;
} BitScanResult;

inline BitScanResult find_least_significant_set_bit(uint32 value)
{
    BitScanResult result = { 0 };
#if defined(_MSC_VER)
    result.found = _BitScanForward((DWORD*)&result.index, value);
#else
    for (uint32 i = 0; i < 32; ++i)
    {
        if (value & (1 << i))
        {
            result.index = i;
            result.found = true;
            break;
        }
    }
#endif
    return result;
}

inline int64 raster_distance(v2l a, v2l b)
{
    int64 res = maxl(absl(a.x - b.x), absl(a.y - b.y));
    return res;
}
static Rect get_brush_bounds(const Brush brush, float relative_scale)
{
    int64 pixel_radius = (int64)((float)brush.radius * relative_scale);
    Rect bounds =
    {
        // top_left
        (v2l) { -pixel_radius, -pixel_radius },
        // bot_right
        (v2l) { pixel_radius, pixel_radius },
    };
    return bounds;
}

static Rect rect_enlarge(Rect src, int64 offset)
{
    Rect result;
    result.left = src.left - offset;
    result.top = src.top - offset;
    result.right = src.right + offset;
    result.bottom = src.bottom + offset;
    return result;
}

static void rasterize_stroke(
        MiltonState* milton_state, const Brush brush, v3f color,
        v2l* points, int64 num_points,
        v2l* rpoints /* May be null. Points already rasterized.*/ )
{
    static uint32 mask_a = 0xff000000;
    static uint32 mask_r = 0x00ff0000;
    static uint32 mask_g = 0x0000ff00;
    static uint32 mask_b = 0x000000ff;
    uint32 shift_a = find_least_significant_set_bit(mask_a).index;
    uint32 shift_r = find_least_significant_set_bit(mask_r).index;
    uint32 shift_g = find_least_significant_set_bit(mask_g).index;
    uint32 shift_b = find_least_significant_set_bit(mask_b).index;

    /* static const float gamma = 1.8f; */
    static const float gamma = 2.2f;  // I think this is OK for Windows.

    color.r = powf(color.r, gamma);
    color.g = powf(color.g, gamma);
    color.b = powf(color.b, gamma);

    uint32* pixels = (uint32_t*)milton_state->raster_buffer;

    const float relative_scale = (float)brush.view_scale / (float)milton_state->view_scale;

    assert (num_points > 0);

    Rect points_bounds;
    {
        points_bounds.top_left = points[0];
        points_bounds.bot_right = points[0];
        for (int64 i = 0; i < num_points; ++i)
        {
            v2l point = points[i];
            if (point.x < points_bounds.left)
                points_bounds.left = point.x;
            if (point.x > points_bounds.right)
                points_bounds.right = point.x;
            if (point.y < points_bounds.top)
                points_bounds.top = point.y;
            if (point.y > points_bounds.bottom)
                points_bounds.bottom = point.y;
        }
        points_bounds.top_left = canvas_to_raster(milton_state, points_bounds.top_left);
        points_bounds.bot_right = canvas_to_raster(milton_state, points_bounds.bot_right);
    }

    int64 multisample_factor = 3;  // 3x3 square

    Rect raster_bounds = rect_enlarge(points_bounds, (int64)(relative_scale * brush.radius) + multisample_factor);

    // Clip the raster bounds
    {
        if (raster_bounds.left < 0)
        {
            raster_bounds.left = 0;
        }
        if (raster_bounds.right > milton_state->screen_size.w)
        {
            raster_bounds.right = milton_state->screen_size.w;
        }

        if (raster_bounds.top < 0)
        {
            raster_bounds.top = 0;
        }
        if (raster_bounds.bottom > milton_state->screen_size.h)
        {
            raster_bounds.bottom = milton_state->screen_size.h;
        }
    }

    // Transform to canvas
    for(int64 i = 0; i < num_points; ++i)
    {
        rpoints[i] = canvas_to_raster(milton_state, points[i]);
    }

    // Paint..

    for (int64 y = raster_bounds.top; y < raster_bounds.bottom; ++y)
    {
        for (int64 x = raster_bounds.left; x < raster_bounds.right; ++x)
        {
            // i,j is our test point
            v2l test_point = { x, y };

            // Iterate through stroke. When inside, draw
            /* v2l prev_point = canvas_to_raster(milton_state, points[0]); */
            v2l prev_point = rpoints[0];
            int64 i = 0;
            while ( i < num_points )
            {
                /* v2l canvas_point = points[i]; */
                /* v2l base_point = canvas_to_raster(milton_state, canvas_point); */
                v2l base_point = rpoints[i];

                // Either do interpolation or increase index to get next point.
#if 0
                if (raster_distance(prev_point, base_point) > 1)
                {
                    v2l delta = sub_v2l(base_point, prev_point);
                    float magnitude = sqrtf((float)(delta.x * delta.x) + (float)(delta.y * delta.y));
                    float dx = 2 * (float)delta.x / magnitude;
                    float dy = 2 * (float)delta.y / magnitude;
                    prev_point = add_v2l(prev_point, (v2l){(int64)dx, (int64)dy});
                    base_point = prev_point;
                }
                else
                {

                    ++i; // ready to get next point next frame.
                }
#else
                ++i;
#endif

                // TODO: Check bounding box for stroke at this point.

                // Check if inside brush!
                // TODO: multisample
                float brush_alpha = 1.0f;

                v2l diff = sub_v2l(test_point, base_point);
                int64 dist2 = diff.x * diff.x + diff.y * diff.y;
                if (dist2 < (brush.radius * brush.radius * relative_scale * relative_scale) )
                {
                    uint32 pixel_color =
                        ((uint8)(brush_alpha * 255.0f) << shift_a) +
                        ((uint8)(color.r * 255.0f) << shift_r) +
                        ((uint8)(color.g * 255.0f) << shift_g) +
                        ((uint8)(color.b * 255.0f) << shift_b);
                    pixels[y * milton_state->screen_size.w + x] = pixel_color;
                }

                prev_point = base_point;
            }
        }
    }
}

// Returns non-zero if the raster buffer was modified by this update.
static bool32 milton_update(MiltonState* milton_state, MiltonInput* input)
{
    arena_reset(milton_state->transient_arena);
    bool32 updated = 0;
    if (input->scale)
    {
        if (input->scale > 0 && milton_state->view_scale > 2)
        {
            milton_state->view_scale /= 2;
        }
        else if (milton_state->view_scale <= ((int64)1 << 61))
        {
            milton_state->view_scale *= 2;
        }

    }
    // Do a complete re-rasterization.
    if (input->full_refresh || 1)
    {
        uint32* pixels = (uint32_t*)milton_state->raster_buffer;
        for (int y = 0; y < milton_state->screen_size.h; ++y)
        {
            for (int x = 0; x < milton_state->screen_size.w; ++x)
            {
                *pixels++ = 0xffffffff;
            }
        }
        updated = 1;
    }
    Brush brush = { 0 };
    {
        brush.view_scale = milton_state->view_scale;
        brush.radius = 10;
    }
    v3f color = { 0.5f, 0.6f, 0.7f };
    if (input->brush)
    {
        v2l in_point = *input->brush;

        v2l canvas_point = raster_to_canvas(milton_state, in_point);

        // Add to current stroke.

        milton_state->stroke_points[milton_state->num_stroke_points++] = canvas_point;

        v2l* rpoints = arena_alloc_array(milton_state->transient_arena, milton_state->num_stroke_points, v2l);

        rasterize_stroke(milton_state, brush, color, milton_state->stroke_points,
                milton_state->num_stroke_points, rpoints);
        updated = 1;
    }
    else if (milton_state->num_stroke_points > 0)
    {
        // Push stroke to history.
        Stroke stored;
        stored.rpoints = arena_alloc_array(milton_state->root_arena, milton_state->num_stroke_points, v2l);
        stored.brush = brush;
        stored.points = arena_alloc_array(milton_state->root_arena,
                milton_state->num_stroke_points, v2l);
        memcpy(stored.points, milton_state->stroke_points,
                milton_state->num_stroke_points * sizeof(v2l));
        stored.num_points = milton_state->num_stroke_points;

        milton_state->stored_strokes[milton_state->num_stored_strokes++] = stored;

        milton_state->num_stroke_points = 0;
    }
    if (input->reset)
    {
        milton_state->view_scale = 1 << 16;
        milton_state->num_stored_strokes = 0;
        updated = 1;
    }
    // Rasterize *every* stroke...
    for (int i = 0; i < milton_state->num_stored_strokes; ++i)
    {
        Stroke* stored = &milton_state->stored_strokes[i];
        rasterize_stroke(milton_state, stored->brush, color, stored->points, stored->num_points,
                stored->rpoints);
    }

    return updated;
}
