// milton.h
// (c) Copyright 2015 by Sergio Gonzalez


#include "libserg/defaults.h"

// ==== Order matters. ====
//
//      We are compiling a big-blob of C code. Not multiple files. Everything
//      is #include'd only once.
//
//      There are only two places where we can add #include directives:
//          - This file.
//          - Platform-dependent *.c files.
//          - Be crystal clear on why these rules are broken when they are
//          broken. (if ever)
//
//      Every other file should assume that it knows about every function it
//      needs to call and every struct it uses. It is our responsibility to
//      include things in the right order in this file to make the program
//      compile.
//
// ========================

#include <math.h>  // powf
#include <float.h>

#include "libserg/gl_helpers.h"
#include "vector.generated.h"  // Generated by metaprogram

#include "utils.h"
#include "color.h"
#include "canvas.h"

typedef struct MiltonGLState_s
{
    GLuint quad_program;
    GLuint texture;
    GLuint quad_vao;
} MiltonGLState;

typedef struct MiltonState_s
{
    int32_t     full_width;             // Dimensions of the raster
    int32_t     full_height;
    uint8_t     bytes_per_pixel;
    uint8_t*    raster_buffer;
    size_t      raster_buffer_size;

    // The canvas is rendered in blocks of size (block_size*block_size).
    int32   block_size;

    MiltonGLState* gl;

    ColorManagement cm;

    ColorPicker picker;

    Brush brush;
    int32 brush_size;  // In screen pixels

    bool32 canvas_blocked;  // When interacting with the UI.

    v2i screen_size;

    // Maps screen_size to a rectangle in our infinite canvas.
    int32 view_scale;

    v2i     last_point;  // Last input point. Used to determine area to update.
    Stroke  working_stroke;

    Stroke  strokes[4096];  // TODO: Create a deque to store arbitrary number of strokes.
    int32   num_strokes;

    // Heap
    Arena*      root_arena;         // Persistent memory.
    Arena*      transient_arena;    // Gets reset after every call to milton_update().

} MiltonState;

typedef struct MiltonInput_s
{
    bool32 full_refresh;
    bool32 reset;
    bool32 end_stroke;
    v2i* point;
    int scale;
} MiltonInput;

#include "rasterizer.h"

static void milton_gl_backend_draw(MiltonState* milton_state)
{
    MiltonGLState* gl = milton_state->gl;
    glTexImage2D(
            GL_TEXTURE_2D, 0, GL_RGBA,
            milton_state->screen_size.w, milton_state->screen_size.h,
            0, GL_RGBA, GL_UNSIGNED_BYTE, (GLvoid*)milton_state->raster_buffer);
    glUseProgram(gl->quad_program);
    glBindVertexArray(gl->quad_vao);
    GLCHK (glDrawArrays (GL_TRIANGLE_FAN, 0, 4) );
}

static void milton_gl_backend_init(MiltonState* milton_state)
{
    // Init quad program
    {
        const char* shader_contents[2];

        shader_contents[0] =
            "#version 330\n"
            "#extension GL_ARB_explicit_uniform_location : enable\n"
            "layout(location = 0) in vec2 position;\n"
            "\n"
            "out vec2 coord;\n"
            "\n"
            "void main()\n"
            "{\n"
            "   coord = (position + vec2(1,1))/2;\n"
            "   coord.y = 1 - coord.y;"
            "   // direct to clip space. must be in [-1, 1]^2\n"
            "   gl_Position = vec4(position, 0.0, 1.0);\n"
            "}\n";


        shader_contents[1] =
            "#version 330\n"
            "#extension GL_ARB_explicit_uniform_location : enable\n"
            "\n"
            "layout(location = 1) uniform sampler2D buffer;\n"
            "in vec2 coord;\n"
            "out vec4 out_color;\n"
            "\n"
            "void main(void)\n"
            "{\n"
            // TODO: Why RGB to BGR?
            "   out_color = texture(buffer, coord).bgra;"
            "}\n";

        GLuint shader_objects[2] = {0};
        for ( int i = 0; i < 2; ++i )
        {
            GLuint shader_type = (i == 0) ? GL_VERTEX_SHADER : GL_FRAGMENT_SHADER;
            shader_objects[i] = gl_compile_shader(shader_contents[i], shader_type);
        }
        milton_state->gl->quad_program = glCreateProgram();
        gl_link_program(milton_state->gl->quad_program, shader_objects, 2);

        glUseProgram(milton_state->gl->quad_program);
        glUniform1i(1, 0 /*GL_TEXTURE0*/);
    }

    // Create texture
    {
        GLCHK (glActiveTexture (GL_TEXTURE0) );
        // Create texture
        GLCHK (glGenTextures   (1, &milton_state->gl->texture));
        GLCHK (glBindTexture   (GL_TEXTURE_2D, milton_state->gl->texture));

        // Note for the future: These are needed.
        GLCHK (glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
        GLCHK (glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
        GLCHK (glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER));
        GLCHK (glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER));

        // Pass a null pointer, texture will be filled by opencl ray tracer
        GLCHK ( glTexImage2D(
                    GL_TEXTURE_2D, 0, GL_RGBA,
                    milton_state->screen_size.w, milton_state->screen_size.h,
                    0, GL_RGBA, GL_FLOAT, NULL) );
    }
    // Create quad
    {
        //const GLfloat u = 1.0f;
#define u -1.0f
        // full
        GLfloat vert_data[] =
        {
            -u, u,
            -u, -u,
            u, -u,
            u, u,
        };
#undef u
        GLCHK (glGenVertexArrays(1, &milton_state->gl->quad_vao));
        GLCHK (glBindVertexArray(milton_state->gl->quad_vao));

        GLuint vbo;
        GLCHK (glGenBuffers(1, &vbo));
        GLCHK (glBindBuffer(GL_ARRAY_BUFFER, vbo));

        GLCHK (glBufferData (GL_ARRAY_BUFFER, sizeof(vert_data), vert_data, GL_STATIC_DRAW));
        GLCHK (glEnableVertexAttribArray (0) );
        GLCHK (glVertexAttribPointer     (/*attrib location*/0,
                    /*size*/2, GL_FLOAT, /*normalize*/GL_FALSE, /*stride*/0, /*ptr*/0));
    }
}

#ifndef NDEBUG
static void milton_startup_tests()
{
    v3f rgb = hsv_to_rgb((v3f){ 0 });
    assert(
            rgb.r == 0 &&
            rgb.g == 0 &&
            rgb.b == 0
          );
    rgb = hsv_to_rgb((v3f){ 0, 0, 1.0 });
    assert(
            rgb.r == 1 &&
            rgb.g == 1 &&
            rgb.b == 1
          );
    rgb = hsv_to_rgb((v3f){ 120, 1.0f, 0.5f });
    assert(
            rgb.r == 0 &&
            rgb.g == 0.5 &&
            rgb.b == 0
          );
    rgb = hsv_to_rgb((v3f){ 0, 1.0f, 1.0f });
    assert(
            rgb.r == 1.0 &&
            rgb.g == 0 &&
            rgb.b == 0
          );
}
#endif

static void milton_init(MiltonState* milton_state)
{
#ifndef NDEBUG
    milton_startup_tests();
#endif
    // Allocate enough memory for the maximum possible supported resolution. As
    // of now, it seems like future 8k displays will adopt this resolution.
    milton_state->full_width      = 7680;
    milton_state->full_height     = 4320;
    milton_state->bytes_per_pixel = 4;
    milton_state->view_scale      = (1 << 12);
    milton_state->num_strokes     = 0;  // Working stroke is index 0

    milton_state->gl = arena_alloc_elem(milton_state->root_arena, MiltonGLState);

    milton_state->block_size = 8;

    color_init(&milton_state->cm);

    // Init picker
    {
        int32 bound_radius_px = 100;
        float wheel_half_width = 12;
        milton_state->picker.center = (v2i){ 120, 120 };
        milton_state->picker.bound_radius_px = bound_radius_px;
        milton_state->picker.wheel_half_width = wheel_half_width;
        milton_state->picker.wheel_radius = (float)bound_radius_px - 5.0f - wheel_half_width;
        milton_state->picker.hsv = (v3f){ 0.0f, 1.0f, 0.7f };
        Rect bounds;
        bounds.left = milton_state->picker.center.x - bound_radius_px;
        bounds.right = milton_state->picker.center.x + bound_radius_px;
        bounds.top = milton_state->picker.center.y - bound_radius_px;
        bounds.bottom = milton_state->picker.center.y + bound_radius_px;
        milton_state->picker.bounds = bounds;
        milton_state->picker.pixels = arena_alloc_array(
                milton_state->root_arena, (4 * bound_radius_px * bound_radius_px), uint32);
        picker_update(&milton_state->picker,
                (v2i){
                milton_state->picker.center.x + (int)(milton_state->picker.wheel_radius),
                milton_state->picker.center.y
                });
    }
    milton_state->brush_size = 10;

    Brush brush = { 0 };
    {
        brush.radius = milton_state->brush_size * milton_state->view_scale;
        brush.alpha = 0.5f;
        brush.color = hsv_to_rgb(milton_state->picker.hsv);
    }
    milton_state->brush = brush;

    int closest_power_of_two = (1 << 27);  // Ceiling of log2(width * height * bpp)
    milton_state->raster_buffer_size = closest_power_of_two;

    milton_state->raster_buffer = arena_alloc_array(milton_state->root_arena,
            milton_state->raster_buffer_size, uint8);

    milton_gl_backend_init(milton_state);
}



inline bool32 is_user_drawing(MiltonState* milton_state)
{
    bool32 result = milton_state->working_stroke.num_points > 0;
    return result;
}

// Our "render loop" inner function.
static void milton_update(MiltonState* milton_state, MiltonInput* input)
{
    arena_reset(milton_state->transient_arena);

    MiltonRenderFlags render_flags = MiltonRenderFlags_none;

    // TODO: this should go away from MiltonInput
    if (input->full_refresh)
    {
        render_flags |= MiltonRenderFlags_full_redraw;
    }
    if (input->scale)
    {
        render_flags |= MiltonRenderFlags_full_redraw;
        static float scale_factor = 1.5f;
        static int32 view_scale_limit = 1000000;
        if (input->scale > 0 && milton_state->view_scale > 2)
        {
            milton_state->view_scale = (int32)(milton_state->view_scale / scale_factor);
        }
        else if (milton_state->view_scale < view_scale_limit)
        {
            milton_state->view_scale = (int32)(milton_state->view_scale * scale_factor) + 1;
        }
        milton_state->brush.radius = milton_state->brush_size * milton_state->view_scale;
    }

    if (input->reset)
    {
        render_flags |= MiltonRenderFlags_full_redraw;
        milton_state->num_strokes = 0;
        milton_state->strokes[0].num_points = 0;
        milton_state->working_stroke.num_points = 0;
    }

    bool32 finish_stroke = false;
    if (input->point)
    {
        v2i point = *input->point;
        if (!is_user_drawing(milton_state) && is_inside_picker(&milton_state->picker, point))
        {
            ColorPickResult pick_result = picker_update(&milton_state->picker, point);
            if (pick_result & ColorPickResult_change_color)
            {
                milton_state->brush.color = hsv_to_rgb(milton_state->picker.hsv);
            }
            milton_state->canvas_blocked = true;
            render_flags |= MiltonRenderFlags_picker_updated;
        }
        else if (!milton_state->canvas_blocked)
        {
            v2i in_point = *input->point;

            // Avoid creating really large update rects when starting. new strokes
            if (milton_state->working_stroke.num_points == 0)
            {
                milton_state->last_point = in_point;
            }

            v2i canvas_point = raster_to_canvas(milton_state->screen_size, milton_state->view_scale, in_point);

            // TODO: make deque!!
            if (milton_state->working_stroke.num_points < LIMIT_STROKE_POINTS)
            {
                // Add to current stroke.
                milton_state->working_stroke.points[milton_state->working_stroke.num_points++] = canvas_point;
                milton_state->working_stroke.brush = milton_state->brush;
                milton_state->working_stroke.bounds =
                    bounding_rect_for_points(milton_state->working_stroke.points,
                            milton_state->working_stroke.num_points);

            }

            milton_state->last_point = in_point;
        }
        if (milton_state->canvas_blocked)
        {
            v2f fpoint = v2i_to_v2f(point);
            ColorPicker* picker = &milton_state->picker;
            if  (picker_wheel_active(picker))
            {
                //if (picker_is_within_wheel(picker, fpoint))
                if (is_inside_triangle(fpoint, picker->a, picker->b, picker->c))
                {
                    picker_wheel_deactivate(picker);
                }
                else
                {
                    picker_update_wheel(&milton_state->picker, fpoint);
                    milton_state->brush.color = hsv_to_rgb(milton_state->picker.hsv);
                }
                render_flags |= MiltonRenderFlags_picker_updated;
            }
        }
    }

    if (input->end_stroke)
    {
        if (milton_state->canvas_blocked)
        {
            picker_wheel_deactivate(&milton_state->picker);
            milton_state->canvas_blocked = false;
        }
        else
        {
            if (milton_state->num_strokes < 4096)
            {
                // Copy current stroke.
                milton_state->strokes[milton_state->num_strokes++] = milton_state->working_stroke;
                // Clear working_stroke
                {
                    milton_state->working_stroke.num_points = 0;
                }
            }
        }
    }

    milton_render(milton_state, render_flags);
}
